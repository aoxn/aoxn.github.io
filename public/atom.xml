<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>理想的路上</title>
  
  <subtitle>一路前行</subtitle>
  <link href="http://aoxn.github.io/atom.xml" rel="self"/>
  
  <link href="http://aoxn.github.io/"/>
  <updated>2022-06-08T04:32:50.008Z</updated>
  <id>http://aoxn.github.io/</id>
  
  <author>
    <name>spacexnice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>遇见复原力</title>
    <link href="http://aoxn.github.io/2022/06/08/%E9%81%87%E8%A7%81%E5%A4%8D%E5%8E%9F%E5%8A%9B/"/>
    <id>http://aoxn.github.io/2022/06/08/%E9%81%87%E8%A7%81%E5%A4%8D%E5%8E%9F%E5%8A%9B/</id>
    <published>2022-06-08T04:32:49.000Z</published>
    <updated>2022-06-08T04:32:50.008Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Kubernetes API设计哲学</title>
    <link href="http://aoxn.github.io/2017/12/16/KuberntesAPI%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/"/>
    <id>http://aoxn.github.io/2017/12/16/KuberntesAPI%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/</id>
    <published>2017-12-16T07:21:02.000Z</published>
    <updated>2022-06-08T02:09:14.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-API设计哲学"><a href="#Kubernetes-API设计哲学" class="headerlink" title="Kubernetes API设计哲学"></a>Kubernetes API设计哲学</h1><p>kubernetes API设计时遵循了如下几个特征，声明式的API设计、水平触发的reconcile、异步的pull模式</p><h2 id="声明式（Declarative）"><a href="#声明式（Declarative）" class="headerlink" title="声明式（Declarative）"></a>声明式（Declarative）</h2><p>用户指定的是期望达到的状态，而不是操作命令。<br>Kubernetes API设计的理念如下： 用户将一个资源对象的期望状态通过描述文件的方式发送给API接口，然后API接口通过不间断的操作使资源对象达到并稳定在期望的状态之上。例如，用户将一个具有多个副本、及指定版本的deployment发送到API接口时，API首先对该资源对象做校验然后进行持久化存储，接下来一个reconcile操作会取回该资源并执行该资源的定义操作，直到该资源的实际状态与定义的期望状态一致。期间如果实际状态被意外更改，仍然会被reconcile到期望状态。</p><p><strong>reconcile</strong><br>reconcile是一组预定义的循环操作(通常的实现是controller-manager)，watch storage上资源对象的期望状态的变化，并对比资源的本地实际状态，执行相关操作使资源最终达到该期望的一致状态，具有幂等性。<br><img src="/upload/15134909004013.jpg"></p><h2 id="水平触发（Level-trigger）"><a href="#水平触发（Level-trigger）" class="headerlink" title="水平触发（Level trigger）"></a>水平触发（Level trigger）</h2><p>Kubernetes API是基于水平触发的实现，系统会驱动资源达到当前所期望的状态，而不管在此之前被设置了哪些不同的期望状态，以当前为基准。例如对当前正在进行rollout的deployment更改其镜像，会促使系统放弃执行当前未完成的rollout,转而进入新的desired state reconcile 流程，即切换到最新的修改上。</p><h2 id="异步性（Asynchronous）"><a href="#异步性（Asynchronous）" class="headerlink" title="异步性（Asynchronous）"></a>异步性（Asynchronous）</h2><p>Kubernetes API接口异步的执行资源的desired state reconcile操作。这意味着创建资源的API请求会在完成校验并存储后立刻返回给调用方而不会立刻执行任何的资源创建动作。这也会导致许多创建中的错误不会在这个阶段返回给用户。解决的方式是定义良好的事件通知机制，资源reconcile过程中产生的错误信息写入到资源关联的事件中，用户通过watch事件了解创建过程。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/kubernetes-incubator/apiserver-builder/blob/master/docs/concepts/api_building_overview.md">Building and using Kubernetes API</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kubernetes-API设计哲学&quot;&gt;&lt;a href=&quot;#Kubernetes-API设计哲学&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes API设计哲学&quot;&gt;&lt;/a&gt;Kubernetes API设计哲学&lt;/h1&gt;&lt;p&gt;kubern</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://aoxn.github.io/categories/Kubernetes/"/>
    
    <category term="Container" scheme="http://aoxn.github.io/categories/Kubernetes/Container/"/>
    
    <category term="容器" scheme="http://aoxn.github.io/categories/Kubernetes/Container/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="Kubernetes" scheme="http://aoxn.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>内核页表的传递</title>
    <link href="http://aoxn.github.io/2016/01/27/pagetable/"/>
    <id>http://aoxn.github.io/2016/01/27/pagetable/</id>
    <published>2016-01-27T01:24:44.000Z</published>
    <updated>2022-06-08T02:09:14.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h2><p>每个用户进程都有自己的页全局目录及页表，然后内核代表进程在内核态执行，此时如果内核代码修改了内核页表，那么这些修改是如何传递到其他用户进程的？毕竟所有用户进程维护自己的页表，同时关于内核线性空间的页表还必须相同，这个是如何做到的？</p><span id="more"></span><p>答案是:</p><p>map_vm_area()并不触及当前进程页表，而是直接修改init进程页表也就是主内核页表。一旦内核代表当前进程访问非连续内存区是，缺页发生，缺页处理程序会检查该地址是否是内核地址，并且该线性地址是否在主内核页表中。一旦处理程序发现一个主内核页表的有一个该线性地址的非空项，则将该项拷贝到当前进程的页表中。</p><h2 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h2><p>那么问题又来了，第一次内核访问非连续存储区的时候，由于进程页表的相应项为空会发生缺页异常，但是如果此后主内核页表项被修改，然后内核再次代表该进程访问非连续物理内存区的时候，由于页表已经被拷贝过旧的值，因此不会发生缺页异常，因此就会访问都错误的非连续的内存区，是这样么？</p><p>答案是：</p><p>因为在上一步的页表拷贝中，只拷贝了页全局目录的部分项，因此当前进程与主内核页表共享相同的页表项，并且这些页表项一旦被分配就不会被回收，但可以修改。这样所有对主内核页表的修改都会传递到当前进程。如果进程试图访问一个已经被释放发非连续内存区也会引发缺页异。</p><p>参见《深入理解Linux内核》</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题一：&quot;&gt;&lt;a href=&quot;#问题一：&quot; class=&quot;headerlink&quot; title=&quot;问题一：&quot;&gt;&lt;/a&gt;问题一：&lt;/h2&gt;&lt;p&gt;每个用户进程都有自己的页全局目录及页表，然后内核代表进程在内核态执行，此时如果内核代码修改了内核页表，那么这些修改是如何传递到其他用户进程的？毕竟所有用户进程维护自己的页表，同时关于内核线性空间的页表还必须相同，这个是如何做到的？&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://aoxn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux内核" scheme="http://aoxn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="页表" scheme="http://aoxn.github.io/tags/%E9%A1%B5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>进程切换时的现场保护问题</title>
    <link href="http://aoxn.github.io/2015/11/05/swithprocess/"/>
    <id>http://aoxn.github.io/2015/11/05/swithprocess/</id>
    <published>2015-11-05T14:53:06.000Z</published>
    <updated>2022-06-08T02:09:14.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程切换流程"><a href="#进程切换流程" class="headerlink" title="进程切换流程"></a>进程切换流程</h2><p>进程的切换只会发生在内核精心定义的点上：schedule()函数。从本质上来说进程的切换由两个步骤完成，或两个标志性动作：  </p><ul><li>1.切换页全局目录来安装一个新的地址空间，cr3寄存器。<br>这里请考虑这样一个问题，一旦页全局目录被切换成其他进程的，那么eip在取下一条指令时通过页表映射的方式还能正常的取到当前执行流的下一条指令吗？毕竟两个进程的页全局目录、页表大部分情况肯定会不一样。<br>答案是：进程切换发生在内核态，所有代码的引用的地址空间大于0xC0000000,这部分页表属于主内核页表，而所有进程具有相同的主内核页表（至于为何具有相同主内核也表，见下一节），所以指令可以正常取并执行。  </li><li>2.切换内核态堆栈与硬件上下文。<br>那么切换时的现场保护问题，尤其是SS段寄存器和esp寄存器的保护 。由于进程的切换发生在内核态，通常在进入内核态中断发生时，硬件上下文会被自动保存。</li></ul><span id="more"></span><h2 id="切换问题"><a href="#切换问题" class="headerlink" title="切换问题"></a>切换问题</h2><p>一直有一个疑问，在中断发生时上下文切换的时候会发生栈的切换，并且把原来的栈段寄存器SS和esp寄存器的值一起保存到新的内核栈段寄存器SS和esp寄存器指向的内核栈，而且这个时候还不能使用任何的其他寄存器辅助（因为硬件上下文还没有保存，任何对寄存器的引用都会破坏进程的上下文），并且任何的push操作都会改变当前的esp，这个切换过程究竟是如何实现的？</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>MDD，硬件上下文的切换是硬件自动完成的，不需要软件做。软件做的只是提供好中断号、idtr寄存器、gdtr寄存器、tr寄存器的值。<br>中断发生时，硬件做了一系列工作，包含获取中断号，从idtr寄存器根据中断号找到中断处理程序入口地址CS：EIP，根据CS及gdtr寄存器找到中断入口代码的段基址及特权位，判断如果特权位发生变化则需要切换到内核栈，切换的过程是从tr寄存器找到当前进程的TSS段，然后把TSS段里保存的当前进程的内核栈SS：ESP放入当前SS：ESP中，并将原来的SS：ESP值push到当前栈中，然后push CS,EIP,EFLAG等寄存器。注意这些都是硬件完成的。而通用寄存器的保护工作应该是由中断处理程序ISR做的。</p><pre><code>参见《深入理解Linux内核》</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;进程切换流程&quot;&gt;&lt;a href=&quot;#进程切换流程&quot; class=&quot;headerlink&quot; title=&quot;进程切换流程&quot;&gt;&lt;/a&gt;进程切换流程&lt;/h2&gt;&lt;p&gt;进程的切换只会发生在内核精心定义的点上：schedule()函数。从本质上来说进程的切换由两个步骤完成，或两个标志性动作：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.切换页全局目录来安装一个新的地址空间，cr3寄存器。&lt;br&gt;这里请考虑这样一个问题，一旦页全局目录被切换成其他进程的，那么eip在取下一条指令时通过页表映射的方式还能正常的取到当前执行流的下一条指令吗？毕竟两个进程的页全局目录、页表大部分情况肯定会不一样。&lt;br&gt;答案是：进程切换发生在内核态，所有代码的引用的地址空间大于0xC0000000,这部分页表属于主内核页表，而所有进程具有相同的主内核页表（至于为何具有相同主内核也表，见下一节），所以指令可以正常取并执行。  &lt;/li&gt;
&lt;li&gt;2.切换内核态堆栈与硬件上下文。&lt;br&gt;那么切换时的现场保护问题，尤其是SS段寄存器和esp寄存器的保护 。由于进程的切换发生在内核态，通常在进入内核态中断发生时，硬件上下文会被自动保存。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://aoxn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux内核" scheme="http://aoxn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="进程切换" scheme="http://aoxn.github.io/tags/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>关于从x86实模式到保护模式的关键一跳的指令连续执行问题</title>
    <link href="http://aoxn.github.io/2015/11/05/keyjump/"/>
    <id>http://aoxn.github.io/2015/11/05/keyjump/</id>
    <published>2015-11-05T14:06:15.000Z</published>
    <updated>2022-06-08T02:09:14.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>关于实模式与保护模式的基础可以参考《深入理解linux内核》，或相关博文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.实模式下的寻址方式</span><br><span class="line">      cs &lt;&lt;<span class="string">4 + ip</span></span><br><span class="line"><span class="string">2.保护模式下的寻址方式</span></span><br><span class="line"><span class="string">      base(index(cs)) +eip</span></span><br><span class="line"><span class="string">3.x86实模式进入保护模式的代码</span></span><br><span class="line"><span class="string">       lgdt  GdtPtr        //加载 GDTR</span></span><br><span class="line"><span class="string">       cli                       //关中断</span></span><br><span class="line"><span class="string">                                 //打开地址线A20等</span></span><br><span class="line"><span class="string">                                 //下面准备切换到保护模式</span></span><br><span class="line"><span class="string">       mov   %cr0，%eax</span></span><br><span class="line"><span class="string">       or       0x1,%eax</span></span><br><span class="line"><span class="string">       mov   %eax,%cr0 //将cr0的PE位置1，进入保护模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       jmp   dword SelectorSode32:0x0</span></span><br></pre></td></tr></table></figure><p><strong>问题:</strong><br>当打开cr0的PE位的瞬间，处理器进入保护模式，寻址方式改变。此时cs的值并没有改变，并且打开cr0瞬间处理器对cs的解释方式完全不一样，那么问题来了，如何确保在进入保护模式后下一条指令被顺利执行？</p><span id="more"></span><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>你可能会想  </p><ul><li>1.是不是cs段寄存器的内容足够特别，使得无论此时采用实模式的寻址方式还是保护模式的寻址方式所解释出来的地址相等？然后你会发现其实这个cs目前值没有任何规律，完全不对头。</li><li>2.翻一翻x86指令集，发现x86规定，在cpu执行长跳转指令的时候才会自动改变cs寄存器的值。然后你会去找，是不是前后有哪些地方执行过长跳转指令？然后没找到。</li><li>3.然后没招的时候你还可能想是不是并不一定就是接着下一条指令执行呢？然后就真的按照当前cs段的值以实模式的方式计算一下下条指令会在那个地方，最后发现根本行不通。</li></ul><p>** 图书馆、百度、Google齐上阵后发现**</p><h2 id="问题答案"><a href="#问题答案" class="headerlink" title="问题答案"></a>问题答案</h2><p>段寄存器后面都有隐藏的高速缓冲寄存器，当cs寄存器值被更新时，这个高速缓冲寄存器的值会根据当时的寻址方式更新，比如实模式下就是cs&lt;&lt;4后放入高速缓冲寄存器，等需要取指令的时候就直接取高速缓冲寄存器的值与eip相加即可，并不会真的再去cs段寄存器找这个值然后做像保护模式下的寻址方式那样推导。这样就解释了上面的情况，虽然寻址方式改变了，但是cs段寄存器的值没变，高速缓冲寄存器的值就不会变，基址仍然是实模式时的值，从而实际上计算出来的还是实模式的地址，保证了指令流的持续执行。内核在等到切换准备就绪的时候就会执行一个长跳转指令来刷新cs段寄存器的值，从而真的跳转导保护模式下了。</p><pre><code> 可以参考《x86汇编语言：从实模式到保护模式》，里面也做了相关描述。</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;关于实模式与保护模式的基础可以参考《深入理解linux内核》，或相关博文。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.实模式下的寻址方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      cs &amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;4 + ip&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;2.保护模式下的寻址方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;      base(index(cs)) +eip&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;3.x86实模式进入保护模式的代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;       lgdt  GdtPtr        //加载 GDTR&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;       cli                       //关中断&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                                 //打开地址线A20等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;                                 //下面准备切换到保护模式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;       mov   %cr0，%eax&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;       or       0x1,%eax&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;       mov   %eax,%cr0 //将cr0的PE位置1，进入保护模式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;       jmp   dword SelectorSode32:0x0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;问题:&lt;/strong&gt;&lt;br&gt;当打开cr0的PE位的瞬间，处理器进入保护模式，寻址方式改变。此时cs的值并没有改变，并且打开cr0瞬间处理器对cs的解释方式完全不一样，那么问题来了，如何确保在进入保护模式后下一条指令被顺利执行？&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://aoxn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux内核" scheme="http://aoxn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="实模式" scheme="http://aoxn.github.io/tags/%E5%AE%9E%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="保护模式" scheme="http://aoxn.github.io/tags/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于haproxy和keepalived的高可用的私有docker registry</title>
    <link href="http://aoxn.github.io/2015/11/04/highavailableregistry/"/>
    <id>http://aoxn.github.io/2015/11/04/highavailableregistry/</id>
    <published>2015-11-04T14:02:11.000Z</published>
    <updated>2022-06-08T02:09:14.806Z</updated>
    
    <content type="html"><![CDATA[<p>本文用于搭建一个基于haproxy和keepalived的高可用的私有docker registry</p><h2 id="部署结构"><a href="#部署结构" class="headerlink" title="部署结构"></a>部署结构</h2><ul><li>haproxy keepalived 主：221.228.86.4</li><li>haproxy keepalived 备：221.228.86.5</li><li>docker registry 1：    221.228.86.6</li><li>docker registry 2：    221.228.86.67</li><li>VIP : 221.228.86.70</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                    221.228.86.100</span><br><span class="line">             +-----------VIP----------+   </span><br><span class="line">             |                        |</span><br><span class="line">             |                        |</span><br><span class="line">           Master                   Backup</span><br><span class="line">        221.228.86.4             221.228.86.6</span><br><span class="line">        +----------+             +----------+</span><br><span class="line">        | HAProxy  |             | HAProxy  |</span><br><span class="line">        |keepalived|             |keepalived|</span><br><span class="line">        +----------+             +----------+</span><br><span class="line">             |  </span><br><span class="line">             v  </span><br><span class="line">    +--------+---------+ </span><br><span class="line">    |        |         |</span><br><span class="line">    |        |         |</span><br><span class="line">    v        v         v</span><br><span class="line">+------+  +------+  +------+</span><br><span class="line">| WEB1 |  | WEB2 |  | WEB3 |</span><br><span class="line">+------+  +------+  +------+</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="修改docker-daemon-启动参数"><a href="#修改docker-daemon-启动参数" class="headerlink" title="修改docker daemon 启动参数"></a>修改docker daemon 启动参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改/etc/default/docker文件，在DOCKER_OPTS=<span class="string">&quot;--insecure-registry vip:5000&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Docker-Registry-配置"><a href="#Docker-Registry-配置" class="headerlink" title="Docker Registry 配置"></a>Docker Registry 配置</h2><ul><li>参考 <a href="https://github.com/docker/distribution/blob/master/docs/configuration.md">https://github.com/docker/distribution/blob/master/docs/configuration.md</a></li><li>221.228.86.5 221.228.86.67</li><li>在&#x2F;var&#x2F;lib&#x2F;pri_docker_registry&#x2F;目录下建立config.yml配置文件,内容如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line"><span class="built_in">log</span>:</span><br><span class="line">  level: debug</span><br><span class="line">  formatter: json</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">  hooks:</span><br><span class="line">    - <span class="built_in">type</span>: mail</span><br><span class="line">      disabled: <span class="literal">true</span></span><br><span class="line">      levels:</span><br><span class="line">        - panic</span><br><span class="line">      options:</span><br><span class="line">        smtp:</span><br><span class="line">          addr: mail.yy.com:25</span><br><span class="line">          username: xxx</span><br><span class="line">          password: pass</span><br><span class="line">          insecure: <span class="literal">true</span></span><br><span class="line">        from: sender@yy.com</span><br><span class="line">        to:</span><br><span class="line">          - errors@yy.com</span><br><span class="line">storage:</span><br><span class="line">    filesystem:</span><br><span class="line">        rootdirectory: /var/lib/registry</span><br><span class="line">    delete:</span><br><span class="line">      enabled: <span class="literal">true</span></span><br><span class="line">    redirect:</span><br><span class="line">      <span class="built_in">disable</span>: <span class="literal">false</span></span><br><span class="line">http:</span><br><span class="line">    addr: :5000</span><br><span class="line">    headers:</span><br><span class="line">        X-Content-Type-Options: [nosniff]</span><br><span class="line">health:</span><br><span class="line">  storagedriver:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    interval: 10s</span><br><span class="line">    threshold: 3</span><br></pre></td></tr></table></figure><ul><li>在docker registry 1 、2、3上分别执行如下命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p /var/lib/registry</span><br><span class="line">$ docker run -d -p 5000:5000 --net=host --restart=always -v /var/lib/pri_docker_registry/config.yml:/etc/docker/registry/config.yml -v /var/lib/registry:/var/lib/registry -v /etc/ceph/:/etc/ceph/ --name docker-registry registry:2.1</span><br></pre></td></tr></table></figure><p>一定要将ceph的配置文件挂载进入容器，rados访问ceph需要</p><ul><li>配置iptables规则，只允许proxy机器访问</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -d 221.228.86.67/32 -m comment --comment <span class="string">&quot;not allow to be connected except proxy&quot;</span> -j DROP</span><br><span class="line">$ iptables -I INPUT 1 -s 221.228.86.4 -d 221.228.86.67 -j ACCEPT</span><br><span class="line">$ iptables -I INPUT 1 -s 221.228.86.6 -d 221.228.86.67 -j ACCEPT</span><br><span class="line"><span class="comment"># 添加办公网的访问</span></span><br><span class="line">$ iptables -I INPUT -s 183.60.177.224/27 -d 221.228.86.70/32 -j ACCEPT</span><br><span class="line">  <span class="comment"># 配置221.228.86.6</span></span><br><span class="line">$ iptables -A INPUT -d 221.228.86.5/32 -m comment --comment <span class="string">&quot;not allow to be connected except proxy&quot;</span> -j DROP</span><br><span class="line">$ iptables -I INPUT 1 -s 221.228.86.4 -d 221.228.86.5 -j ACCEPT</span><br><span class="line">$ iptables -I INPUT 1 -s 221.228.86.6 -d 221.228.86.5 -j ACCEPT</span><br><span class="line">$ iptables -I INPUT -s 183.60.177.224/27 -d 221.228.86.70/32 -j ACCEPT</span><br></pre></td></tr></table></figure><h2 id="Haproxy-配置"><a href="#Haproxy-配置" class="headerlink" title="Haproxy 配置"></a>Haproxy 配置</h2><ul><li>参考 <a href="https://hub.docker.com/_/haproxy/">https://hub.docker.com/_/haproxy/</a></li><li>在haproxy 主备上分别执行下面命令,在&#x2F;var&#x2F;lib&#x2F;hadporxy&#x2F;目录下建立haproxy.cfg配置文件,内容如下:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    <span class="built_in">log</span> 127.0.0.1 local3 info</span><br><span class="line">    maxconn 4096</span><br><span class="line">    nbproc 1</span><br><span class="line">    pidfile /var/lib/haproxy/haproxy.pid</span><br><span class="line">defaults</span><br><span class="line">    maxconn 2000</span><br><span class="line">    <span class="built_in">timeout</span> connect 5000</span><br><span class="line">    <span class="built_in">timeout</span> client 30000</span><br><span class="line">    <span class="built_in">timeout</span> server 30000</span><br><span class="line">    mode http</span><br><span class="line">    stats uri /admin?stats</span><br><span class="line">    option forwardfor</span><br><span class="line">frontend http_server</span><br><span class="line">    <span class="built_in">bind</span> :5000</span><br><span class="line">    <span class="built_in">log</span> global</span><br><span class="line">    default_backend docker-registry</span><br><span class="line">    <span class="comment">#acl test hdr_dom(host) -i test.domain.com</span></span><br><span class="line">    <span class="comment">#use_backend cache_test if test</span></span><br><span class="line">backend docker-registry</span><br><span class="line">    <span class="comment">#balance roundrobin</span></span><br><span class="line">    balance <span class="built_in">source</span></span><br><span class="line">    option httpchk GET /v2/ HTTP/1.1\r\nHost:221.228.86.6</span><br><span class="line">    server inst1 221.228.86.5:5000 check inter 5000 fall 3</span><br><span class="line">    server inst2 221.228.86.67:5000 check inter 5000 fall 3</span><br><span class="line"><span class="comment">#HAProxy管理页面 </span></span><br><span class="line">listen admin_stat</span><br><span class="line">    <span class="built_in">bind</span> *:1158                    <span class="comment">#管理页面端口</span></span><br><span class="line">    mode http                        </span><br><span class="line">    stats refresh 10s                <span class="comment">#自动刷新时间</span></span><br><span class="line">    stats uri /haproxy                 <span class="comment">#页面名称</span></span><br><span class="line">    stats realm Haproxy\ Statistics     <span class="comment">#登录提示</span></span><br><span class="line">    stats auth admin:admin    <span class="comment">#帐号密码</span></span><br><span class="line">    stats hide-version </span><br><span class="line">stats admin <span class="keyword">if</span> TRUE</span><br></pre></td></tr></table></figure><h4 id="创建haproxy-registry容器"><a href="#创建haproxy-registry容器" class="headerlink" title="创建haproxy-registry容器"></a>创建haproxy-registry容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p /var/lib/haproxy</span><br><span class="line">$ docker run -d --name haproxy-registry --net=host -v /var/lib/haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro haproxy:1.5</span><br></pre></td></tr></table></figure><h4 id="清除Iptables-规则，目前让所有机器都能访问该proxy"><a href="#清除Iptables-规则，目前让所有机器都能访问该proxy" class="headerlink" title="清除Iptables 规则，目前让所有机器都能访问该proxy"></a>清除Iptables 规则，目前让所有机器都能访问该proxy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -D INPUT -d 221.228.86.5/32 -m comment --comment sigma -j DROP</span><br></pre></td></tr></table></figure><h2 id="Keepalived主备配置"><a href="#Keepalived主备配置" class="headerlink" title="Keepalived主备配置"></a>Keepalived主备配置</h2><p>使用Keeplalived管理浮动IP</p><ul><li>在221.228.86.4 221.228.86.6机器上同时安装keepalived，keepalived配置文件区别设置<h4 id="Ubuntu-Keepalived安装"><a href="#Ubuntu-Keepalived安装" class="headerlink" title="Ubuntu Keepalived安装"></a>Ubuntu Keepalived安装</h4></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install keepalived</span><br></pre></td></tr></table></figure><h4 id="Master（221-228-86-4）服务器配置-x2F-etc-x2F-keepalived-x2F-keepalived-conf"><a href="#Master（221-228-86-4）服务器配置-x2F-etc-x2F-keepalived-x2F-keepalived-conf" class="headerlink" title="Master（221.228.86.4）服务器配置 &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf"></a>Master（221.228.86.4）服务器配置 &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">       xieyaoyao@yy.com</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from mail@example.org</span><br><span class="line">   smtp_server mail.yy.com</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#监测haproxy进程状态，每2秒执行一次</span></span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">    script <span class="string">&quot;/usr/local/keepalived/chk_haproxy.sh&quot;</span></span><br><span class="line">    interval 2</span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER <span class="comment">#标示状态为MASTER</span></span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 101   <span class="comment">#MASTER权重要高于BACKUP</span></span><br><span class="line">    advert_int 1</span><br><span class="line">    mcast_src_ip 221.228.86.4 <span class="comment">#Master服务器IP</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS <span class="comment">#主从服务器验证方式</span></span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_haproxy <span class="comment">#监测haproxy进程状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#VIP</span></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        221.228.86.70 <span class="comment">#虚拟IP</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Backup（221-228-86-6）服务器上的配置-x2F-etc-x2F-keepalived-x2F-keepalived-conf"><a href="#Backup（221-228-86-6）服务器上的配置-x2F-etc-x2F-keepalived-x2F-keepalived-conf" class="headerlink" title="Backup（221.228.86.6）服务器上的配置 &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf"></a>Backup（221.228.86.6）服务器上的配置 &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">   user@example.com</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from mail@example.org</span><br><span class="line">   smtp_server 192.168.x.x</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#监测haproxy进程状态，每2秒执行一次</span></span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">    script <span class="string">&quot;/usr/local/keepalived/chk_haproxy.sh&quot;</span></span><br><span class="line">    interval 2</span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP <span class="comment">#状态为BACKUP</span></span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100  <span class="comment">#权重要低于MASTER</span></span><br><span class="line">    advert_int 1</span><br><span class="line">    mcast_src_ip 221.228.86.6 <span class="comment">#Backup服务器的IP</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_haproxy <span class="comment">#监测haproxy进程状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#VIP</span></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        221.228.86.70 <span class="comment">#虚拟IP</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="chk-haproxy-sh内容-x2F-usr-x2F-local-x2F-keepalived-x2F-chk-haproxy-sh"><a href="#chk-haproxy-sh内容-x2F-usr-x2F-local-x2F-keepalived-x2F-chk-haproxy-sh" class="headerlink" title="chk_haproxy.sh内容 &#x2F;usr&#x2F;local&#x2F;keepalived&#x2F;chk_haproxy.sh"></a>chk_haproxy.sh内容 &#x2F;usr&#x2F;local&#x2F;keepalived&#x2F;chk_haproxy.sh</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># author: weizhifeng</span></span><br><span class="line"><span class="comment"># description: </span></span><br><span class="line"><span class="comment"># 定时查看haproxy是否存在，如果不存在则启动haproxy，</span></span><br><span class="line"><span class="comment"># 如果启动失败，则停止keepalived</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">status=$(docker inspect  -f <span class="string">&quot;&#123;&#123;.State.Running&#125;&#125;&quot;</span> haproxy-registry)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;status&#125;</span>&quot;</span> = <span class="string">&quot;false&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    docker start haproxy-registry</span><br><span class="line">    status2=$(docker inspect  -f <span class="string">&quot;&#123;&#123;.State.Running&#125;&#125;&quot;</span> haproxy-registry)</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;status2&#125;</span>&quot;</span> = <span class="string">&quot;false&quot;</span>  ]; <span class="keyword">then</span></span><br><span class="line">            service keepalived stop</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="启动keepalived服务"><a href="#启动keepalived服务" class="headerlink" title="启动keepalived服务"></a>启动keepalived服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service keepalived start</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文用于搭建一个基于haproxy和keepalived的高可用的私有docker registry&lt;/p&gt;
&lt;h2 id=&quot;部署结构&quot;&gt;&lt;a href=&quot;#部署结构&quot; class=&quot;headerlink&quot; title=&quot;部署结构&quot;&gt;&lt;/a&gt;部署结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;haproxy keepalived 主：221.228.86.4&lt;/li&gt;
&lt;li&gt;haproxy keepalived 备：221.228.86.5&lt;/li&gt;
&lt;li&gt;docker registry 1：    221.228.86.6&lt;/li&gt;
&lt;li&gt;docker registry 2：    221.228.86.67&lt;/li&gt;
&lt;li&gt;VIP : 221.228.86.70&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;                    221.228.86.100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             +-----------VIP----------+   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           Master                   Backup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        221.228.86.4             221.228.86.6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        +----------+             +----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        | HAProxy  |             | HAProxy  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        |keepalived|             |keepalived|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        +----------+             +----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             |  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             v  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    +--------+---------+ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    |        |         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    |        |         |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    v        v         v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+------+  +------+  +------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| WEB1 |  | WEB2 |  | WEB3 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+------+  +------+  +------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="容器" scheme="http://aoxn.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Docker" scheme="http://aoxn.github.io/categories/%E5%AE%B9%E5%99%A8/Docker/"/>
    
    
    <category term="Docker" scheme="http://aoxn.github.io/tags/Docker/"/>
    
    <category term="Registry" scheme="http://aoxn.github.io/tags/Registry/"/>
    
  </entry>
  
</feed>
